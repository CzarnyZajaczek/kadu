===============================================================================
       MOJE UWAGI I WSKAZÓWKI DLA LUDZI PRACUJ¡CYCH NAD PROGRAMEM KADU
===============================================================================

Z powodu do¶æ sporego w ostatnim czasie zarówno biernego jak i
czynnego zainteresowania projektem Kadu w¶ród ludzi u¿ywaj±cych
systemów unixowych, zapad³a decyzja (moja w³asna, choæ mam nadziejê
na poparcie pozosta³ych cz³onków projektu) i¿ wszystkie zasady
dotycz±ce tworzenia i modyfikacji kodu zostan± spisane i bêd±
aktualizowane na u¿ytek developerów i osób trzecich przysy³aj±cych
poprawki i rozszerzenia kodu.

Nie ukrywam, ¿e wiêkszo¶æ zawartych tu pomys³ów i rozwi±zañ pochodzi
z moich prywatnych do¶wiadczeñ. Je¶li których z developerów nie
zgadza siê z czym¶ to chêtnie wezmê udzia³ w dyskusji na ten temat.
£amanie zasad tylko z przyczyn lenistwa i niechlujstwa bêdzie oczywi¶cie
zawziêcie przeze mnie têpione ;)

¯yczê owocnego programowania
Adrian Smarzewski


===============================================================================
                 1. KADU JEST PROGRAMEM W JÊZYKU C++
===============================================================================

Pamiêtaj o tym! Jêzyk C++ jest w du¿ym stopniu spadkobierc± jêzyka C.
Praktycznie ka¿dy program napisany w jêzyku C daje siê skompilowaæ kompilatorem
C++. Nie zapominajcie jednak o tym "++". Wykorzystujcie si³ê i klarowno¶æ
tego jêzyka! Nie stosujcie archaicznych konstrukcji w C. Nie bójcie siê
programowania obiektowego... klas, dziedziczenia, metod wirtualnych...

* Unikaj tworzenia samodzielnych funkcji. W zasadzie powinna byæ tylko jedna
  funkcja - "main". Reszta kodu niech bêdzie zawarta wewn±trz metod
  poszczególnych klas.

* Pojêcie, które mo¿e mieæ wiele instancji np. "u¿ytkownik", "ikona" itp.
  w bardzo naturalny sposób implementujemy za pomoc± klasy. Zmienne (pola)
  wewn±trz klasy nie powinny byæ publiczne. Je¶li chcesz zaimplementowaæ
  w³a¶ciwo¶æ X która mo¿e byæ zmieniana z zewn±trz stwórz prywatn± zmienn±
  X i dwie publiczne metody: setX() zmieniaj±c± dan± warto¶æ i zwracaj±c±
  j± x().

* Pojêcie, które nie powininno mieæ wiêcej ni¿ jednej instancji np.
  "autostatus" czy "menad¿er emotikonów" równie¿ powinno siê implementowaæ
  za pomoc± klasy.
    
  Je¶li obiekt twojej klasy X ma byæ utworzony przy starcie aplikacji i
  nie jest zale¿ny od innych obiektów (czyli mo¿e np. byæ utworzony jako
  pierwszy) mo¿esz zaimplementowaæ kod jako zwyk³± klasê oraz zadeklarowaæ
  jedn± zmienn± klasy X o nazwie np x bêd±c± t± jedyn± instancj± klasy
  (pojêcia).
  
  xxx.h:
  ------
  
  class X
  {
  	public:
  		X();
		void m();
  };
  
  extern X x;
  
  xxx.cpp:
  --------
  
  X::X()
  {
  };
  
  void X::m()
  {
  };
  
  X x;
  
  Je¶li chcesz, aby z pozosta³ej czêsci kodu mo¿na by³o kontrolowaæ kiedy
  obiekt ten bêdzie utworzony, a kiedy zniszczony powiniene¶ zadeklarowaæ
  statyczne (static) publiczne metody create(), destroy() lub on(), off()
  lub te¿ enable(), disable() w zale¿no¶ci od przeznaczenia tworzonej przez
  Ciebie klasy. Konstruktor takiej klasy powinien byæ prywatny. Zabroni
  to innym developerom utworzenia przez przypadek kolejnej instacji.
  Wszystkie metody powinny byæ statyczne i operowaæ na obiekcie Instance.
  
  xxx.h:
  ------
  
  class X
  {
  	private:
		static X* Instance;
  		X();
  	public:
		static void create();
		static void destroy();
		static void m();
  };
  
  xxx.cpp:
  --------
  
  X::X()
  {
  };
  
  void X::create()
  {
  	if(Instance==NULL)
		Instance=new X();
  };
  
  void X::delete()
  {
  	if(Instance!=NULL)
		delete Instance;
  };
    
  void X::m()
  {
  };
  
  X* X::Instance=NULL;


===============================================================================
                 2. KADU JEST PROGRAMEM OPARTYM O QT
===============================================================================

* Staraj siê wykorzystywaæ mechanizmy dostarczone przez bibliotekê QT
  zamiast funkcji z glibc lub kdelibs. U¿ywaj np. klasy QFile zamiast
  funkcji fopen(), fwrite() itp.

* U¿ywaj mechanizmu sygna³ów tam gdzie tylko jest to mo¿liwe i nie powoduje
  zbytniego zamieszania. Sygna³y i sloty to rozwi±zania eleganckie i warto
  z nich korzystaæ.

* Wzoruj±c siê na standardach QT przyjmujemy, ¿e:

	- nazwy metod rozpoczynaj± siê od ma³ej litery, a drugi i kolejne
	  wyrazy nazwy rozpoczynamy wielk± liter±, np: activate(), getFocus()
	  
	- w nazwach klas ka¿dy wyraz nazwy ³±cznie z pierwszym rozpoczynamy
	  wielk± liter±, np: PendingMsgs, EmoticonsManager
	  

===============================================================================
                    3. WYGLAD KODU - ZASADY SK£ADNI
===============================================================================

* Wszystkie wciêcia powinny byæ wykonywane za pomoc± tabulacji a nie spacji!
  Sprawd¼ ustawienia swojego edytora.

* Komentarze przed deklaracjami klas i funkcji powinny byæ otoczone symbolami
  "/**" i "**/". Kod taki jest zgodny z wymogami programów do automatycznego
  tworzenia dokumentacji przy u¿yciu kodu ¼ród³owego (np. kdoc).

* Deklaracja klasy:

	/**
  		opis klasy
		...
	**/
	class <nazwa_klasy> : <lista_klas_podstawowych>
	{
		private:
			zmienna prywatna 1
			zmienna prywatna 2     
			...
			metoda prywatna 1
			metoda prywatna 2     
			...
		protected:
			zmienna chroniona 1
			zmienna chroniona 2
			...
			/**
				opis metody chronionej 1
			**/
			metoda chroniona 1
			/**
				opis metody chronionej 2
			**/     
			metoda chroniona 2     
			...
		public:
			/**
				opis publicznego konstruktora 1
			**/
			publiczny konstruktor 1
			/**
				opis publicznego konstruktora 2
			**/
			publiczny konstruktor 2
			...
			destruktor
			/**
				opis metody publicznej 1
			**/
			metoda publiczna 1
			/**
				opis metody publicznej 2
			**/     
			metoda publiczna 2
			...
	};

* Definiowanie metod:

	<nazwa_klasy>::<nazwa_metody>(<argument1>,<argument2>,...)
	{
		tre¶æ funkcji
		...
	};

* Wyra¿enie warunkowe

	if(<warunek>)
		instrukcja;

	if(<warunek>)
	{
		instrukcja 1;
		instrukcja 2;
		...
	};

* Pêtla while (for i do/while podobnie)

	while(<warunek>)
		instrukcja;

	while(<warunek>)
	{
		instrukcja 1;
		instrukcja 2;
		...
	};


===============================================================================
                    4. ZASADY PRACY W GRUPIE NAD PROJEKTEM 
===============================================================================

* Je¶li nie masz praw zapisu do CVS przysy³aj developerom patche, tworzone
  poleceniem "diff -u". Najlepiej generowaæ je wzglêdem naj¶wie¿szej wersji
  z CVS, ale nie jest to wymagane, je¶li w miêdzyczasie nie by³o powa¿nych
  zmian w kodzie. Patche, które nie na³o¿± siê poprawnie na aktualny kod
  bêd± odrzucane.

* Je¶li masz prawa zapisu do CVS sprawd¼ poleceniem "cvs editors" czy pliki,
  które masz ochotê zmodyfikowaæ nie s± w³a¶nie przypadkiem przez kogo¶
  zmieniane. Nastêpnie poleceniem "cvs edit" powiadom innych developerów
  o fakcie rozpoczêcia modyfikacji. Podczas aktualizowania ¼róde³ na CVS
  podawaj w miarê krótkie, lecz sensowne opisy dokonywanych modyfikacji
  (cvs commit -m "opis").

* Je¶li dokonywana zmiana nie jest tylko poprawk± kodu, lecz dotyczy
  funkcjonalno¶ci programu, nie powiniene¶ podejmowaæ decyzji samodzielnie.
  Skonsultuj planowan± modyfikacjê lub rozbudowê z pozosta³ymi programistami
  nawet je¶li sprawa jest wymieniona w pliku TODO. Przy mniejszych zmianach
  (nie wywracaj±cych projektu do góry nogami) wystarczy akceptacja którego¶
  ze "starych wyjadaczy" ;)
